package org.opentestsystem.delivery.logging;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.ObjectWriter;
import org.apache.commons.lang.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

import java.util.HashMap;
import java.util.Map;

import static java.lang.String.format;
import static java.util.Collections.unmodifiableMap;

/**
 * Centralized event logger.
 */
public class EventLogger {

  private static final Logger logger = LoggerFactory.getLogger(EventLogger.class);
  private static final Marker marker = MarkerFactory.getMarker("event-logger");
  private static final ObjectWriter writer = new ObjectMapper().writer();
  private static Map<String, Long> eventTimes = new HashMap<>();

  public enum Checkpoint {
    NONE,
    ENTER,
    EXIT,
  }

  public interface ILogEvent {
    String name();
  }

  public interface IEventData {
    String name();
  }

  public enum LogEvent implements ILogEvent {
    LOGIN,
    LOGOUT,
    UNKNOWN,
  }

  public enum EventData implements IEventData {
    APP,
    ELAPSED_TIME,
    CHECKPOINT,
    SESSION_ID,
    RESPONSE_CODE,
    SUB_EVENT,
  }

  /**
   * Log event occurrences to centralized logging.
   * <p>
   * These events are intended to be sent to a logstash server and searchable using elastic search.
   *
   * @param app        name of the app writing the log
   * @param logEvent   name of the event occurring
   * @param checkpoint an optional checkpoint name
   * @param sessionId  an optional unique identifier common to a set of log entries (generally a request's session ID)
   * @param message    an optional free-format message string to add to the log entry
   * @param data       optional searchable event data to add to the recorded event
   */
  public static void info(final String app, final String logEvent, final String checkpoint, final String sessionId,
                          final String message, final Map<IEventData, Object> data) {
    log(formatMessage(logEvent, message), getFieldMap(app, logEvent, checkpoint, sessionId, data));
  }

  /**
   * Log event errors to centralized logging.
   * <p>
   * These events are intended to be sent to a logstash server and searchable using elastic search.
   *
   * @param app        name of the app writing the log
   * @param logEvent   name of the event occurring
   * @param checkpoint an optional checkpoint name
   * @param sessionId  an optional unique identifier common to a set of log entries (generally a request's session ID)
   * @param message    an optional free-format message string to add to the log entry
   * @param data       optional searchable event data to add to the recorded event
   */
  public static void error(final String app, final String logEvent, final String checkpoint, final String sessionId,
                           String message, final Map<IEventData, Object> data, final Exception e) {
    error(formatMessage(logEvent, message), getFieldMap(app, logEvent, checkpoint, sessionId, data), e);
  }

  private static void log(final String event, final Map<String, Object> fields) {
    try {
      logger.info(marker, format("EVENT:%s JSON:({\"event_data\": %s})", event, writer.writeValueAsString(fields)));
    } catch (Exception e) {
      logger.warn(marker, format("exception occurred while logging event: %s", event), e);
    }
  }

  private static void error(final String event, final Map<String, Object> fields, final Exception e) {
    try {
      logger.error(marker, format("EVENT:%s JSON:({\"event_data\": %s})", event, writer.writeValueAsString(fields)),
        e);
    } catch (Exception inner) {
      logger.error(marker, format("exception occurred while error event: %s", event), inner);
    }
  }

  private static void addTimerMetrics(final String event, final String checkpoint, Map<IEventData, Object> fields) {
    Long eventTime = eventTimes.get(event);
    if (Checkpoint.ENTER.name().equals(checkpoint)) {
      // entry point - (re)set eventTime and emit nothing
      eventTimes.put(event, System.currentTimeMillis());
    } else {
      if (Checkpoint.EXIT.name().equals(checkpoint)) {
        // exit point - remove timestamp. falls through to default to emit metric.
        eventTimes.remove(event);
      }
      // non entry/exit or missing position marker - emit elapsed metric
      if (null != eventTime) {
        fields.put(EventData.ELAPSED_TIME, System.currentTimeMillis() - eventTime);
      }
    }
  }

  private static Map<String, Object> getFieldMap(final String app, final String event, String checkpoint,
                                                 final String sessionId, final Map<IEventData, Object> data) {
    Map<IEventData, Object> fields = new HashMap<>();
    if (StringUtils.isNotBlank(app)) {
      fields.put(EventData.APP, app);
    }
    if (StringUtils.isNotBlank(checkpoint)) {
      fields.put(EventData.CHECKPOINT, checkpoint);
    }
    if (StringUtils.isNotBlank(sessionId)) {
      fields.put(EventData.SESSION_ID, sessionId);
    }
    if (null != data) {
      fields.putAll(data);
    }
    addTimerMetrics(event, checkpoint, fields);
    Map<String, Object> outputMap = new HashMap<>();
    for (Map.Entry<IEventData, Object> entry : fields.entrySet()) {
      outputMap.put(entry.getKey().name().toLowerCase(), entry.getValue());
    }
    return unmodifiableMap(outputMap);
  }

  private static String formatMessage(final String logEvent, final String message) {
    String result = logEvent;
    if (StringUtils.isNotBlank(message)) {
      result = result + " - " + message;
    }
    return result;
  }
}
