package org.opentestsystem.delivery.logging;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.ObjectWriter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

import java.util.HashMap;
import java.util.Map;

import static java.lang.String.format;
import static java.util.Collections.unmodifiableMap;

/**
 * Centralized event logger.
 */
public class EventLogger {

  private static final Logger logger = LoggerFactory.getLogger(EventLogger.class);
  private static final Marker marker = MarkerFactory.getMarker("event-logger");
  private static final ObjectWriter writer = new ObjectMapper().writer();
  private static Map<ILogEvent, Long> eventTimes = new HashMap<>();

  public enum Checkpoint {
    NONE,
    ENTER,
    EXIT,
  }

  public interface ILogEvent {
    String name();
  }

  public interface IEventData {
    String name();
  }

  public enum LogEvent implements ILogEvent {
    LOGIN,
    LOGOUT,
    UNKNOWN,
  }

  public enum EventData implements IEventData {
    APP,
    ELAPSED_TIME,
    CHECKPOINT,
    SESSION_ID,
    SUB_EVENT,
  }

  /**
   * Log event occurrences to centralized logging.
   * <p>
   * These events are intended to be sent to a logstash server and searchable using elastic search.
   *
   * @param app  name of the app writing the log
   * @param logEvent  name of the event occurring
   * @param checkpoint  an optional checkpoint name
   * @param sessionId  an optional unique identifier common to a set of log entries (generally a request's session ID)
   * @param message  an optional free-format message string to add to the log entry
   * @param data optional searchable event data to add to the recorded event
   */
  public static void info(final String app, final ILogEvent logEvent, final String checkpoint, final String sessionId,
                          final String message, final Map<IEventData, Object> data) {
    log(formatMessage(logEvent, message), getFieldMap(app, logEvent, checkpoint, sessionId, data));
  }

  /**
   * Log event errors to centralized logging.
   * <p>
   * These events are intended to be sent to a logstash server and searchable using elastic search.
   *
   * @param app  name of the app writing the log
   * @param logEvent  name of the event occurring
   * @param checkpoint  an optional checkpoint name
   * @param sessionId  an optional unique identifier common to a set of log entries (generally a request's session ID)
   * @param message  an optional free-format message string to add to the log entry
   * @param data optional searchable event data to add to the recorded event
   */
  public static void error(final String app, final ILogEvent logEvent, final String checkpoint, final String sessionId,
                           String message, final Map<IEventData, Object> data, final Exception e) {
    error(formatMessage(logEvent, message), getFieldMap(app, logEvent, checkpoint, sessionId, data), e);
  }

  private static void log(final String event, final Map<String, Object> fields) {
    try {
      logger.info(marker, format("EVENT:%s JSON:({\"event_data\": %s})", event, writer.writeValueAsString(fields)));
    } catch (Exception e) {
      logger.warn(marker, format("exception occurred while logging event: %s", event), e);
    }
  }

  private static void error(final String event, final Map<String, Object> fields, final Exception e) {
    try {
      logger.error(marker, format("EVENT:%s JSON:({\"event_data\": %s})", event, writer.writeValueAsString(fields)),
        e);
    } catch (Exception inner) {
      logger.error(marker, format("exception occurred while error event: %s", event), inner);
    }
  }

  private static void addTimerMetrics(final ILogEvent event, final String checkpoint, Map<IEventData, Object> fields) {
    Long eventTime = eventTimes.get(event);
    switch (checkpoint) {
      case "ENTER":
        // entry point - (re)set eventTime and emit nothing
        eventTimes.put(event, System.currentTimeMillis());
        break;
      case "EXIT":
        // exit point - remove timestamp. falls through to default to emit metric.
        eventTimes.remove(event);
        // no break;
      default:
        // non entry/exit or missing position marker - emit elapsed metric
        if (null != eventTime) {
          fields.put(EventData.ELAPSED_TIME, System.currentTimeMillis() - eventTime);
        }
        break;
    }
  }

  private static Map<String, Object> getFieldMap(final String app, final ILogEvent event, String checkpoint,
                                                 final String sessionId, final Map<IEventData, Object> data) {
    Map<IEventData, Object> fields = new HashMap<>();
    fields.put(EventData.APP, app);
    if (null == checkpoint) {
      checkpoint = Checkpoint.NONE.name();
    }
    fields.put(EventData.CHECKPOINT, checkpoint);
    if (null != sessionId && !sessionId.isEmpty()) {
      fields.put(EventData.SESSION_ID, sessionId);
    }
    if (null != data) {
      fields.putAll(data);
    }
    addTimerMetrics(event, checkpoint, fields);
    Map<String, Object> outputMap = new HashMap<>();
    for (Map.Entry<IEventData, Object> entry : fields.entrySet()) {
      outputMap.put(entry.getKey().name().toLowerCase(), entry.getValue());
    }
    return unmodifiableMap(outputMap);
  }

  private static String formatMessage(final ILogEvent logEvent, final String message) {
    String result = logEvent.name();
    if (null != message && !message.isEmpty()) {
      result = result + " - " + message;
    }
    return result;
  }
}
